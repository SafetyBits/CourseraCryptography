package week6;

import java.math.BigInteger;

import org.apfloat.Apfloat;
import org.apfloat.ApfloatMath;
import org.apfloat.Apint;

import week2.Utils;

/**
 * Your goal in this project is to break RSA when the public modulus N is
 * generated incorrectly. This should serve as yet another reminder not to
 * implement crypto primitives yourself.
 * 
 * Normally, the primes that comprise an RSA modulus are generated independently
 * of one another. But suppose a developer decides to generate the first prime p
 * by choosing a random number R and scanning for a prime close by. The second
 * prime q is generated by scanning for some other random prime also close to R.
 * We show that the resulting RSA modulus N=pq can be easily factored.
 * 
 * Suppose you are given a composite N and are told that N is a product of two
 * relatively close primes p and q, namely p and q satisfy<br>
 * <code>|p−q|<2N<sup>1/4</sup></code> <b>(*)</b> <br>
 * Your goal is to factor N.
 * 
 * Let A be the arithmetic average of the two primes, that is A=(p+q)/2. Since p
 * and q are odd, we know that p+q is even and therefore A is an integer.
 * 
 * To factor N you first observe that under condition (*) the quantity √N is
 * very close to A. In particular A − √N <1 as shown below. But since A is an
 * integer, rounding √N up to the closest integer reveals the value of A. In
 * code, <code>A=ceil(sqrt(N))</code> where "ceil" is the ceiling function.
 * Visually, the numbers p,q,√N and A are ordered as follows:<br>
 * <img src="docs/images_proj6-fig.jpg"> <br>
 * Since A is the exact mid-point between p and q there is an integer x such
 * that <code>p = A−x</code> and <code>q = A+x</code>. But then
 * <code>N=pq=(A−x)(A+x)=A<sup>2</sup>−x<sup>2</sup></code> and therefore
 * <code>x=sqrt(A<sup>2</sup>−N)</code>. Now, given x and A you can find the
 * factors p and q of N since <code>p=A−x</code> and <code>q=A+x</code>.
 * 
 * In the following challenges, you will factor the given moduli using the
 * method outlined above. To solve this assignment it is best to use an
 * environment that supports multi-precision arithmetic and square roots. In
 * Python you could use the gmpy2 module. In C you can use GMP.
 * <p>
 * Factoring challenge #1: The following modulus N is a products of two primes p
 * and q where <code>|p−q|<2N<sup>1/4</sup></code>. Find the smaller of the two
 * factors and enter it as a decimal integer.
 * <p>
 * <code>N = 17976931348623159077293051907890247336179769789423065727343008115 \<br>
 * 77326758055056206869853794492129829595855013875371640157101398586 \<br>
 * 47833778606925583497541085196591615128057575940752635007475935288 \<br>
 * 71082364994994077189561705436114947486504671101510156394068052754 \<br>
 * 0071584560878577663743040086340742855278549092581</code>
 * 
 * <p>
 * Factoring challenge #2: The following modulus N is a products of two primes p
 * and q where <code>|p−q|<2<sup>11</sup>N<sup>1/4</sup></code>. Find the
 * smaller of the two factors and enter it as a decimal integer. Hint: in this
 * case <code>A−√N<2<sup>20</sup></code> so try scanning for A from √N upwards,
 * until you succeed in factoring N.
 * <p>
 * <code>N = 6484558428080716696628242653467722787263437207069762630604390703787 \<br>
 * 9730861808111646271401527606141756919558732184025452065542490671989 \<br>
 * 2428844841839353281972988531310511738648965962582821502504990264452 \<br>
 * 1008852816733037111422964210278402893076574586452336833570778346897 \<br>
 * 15838646088239640236866252211790085787877</code>
 * 
 * <p>
 * Factoring challenge #3: (extra credit) The following modulus N is a products
 * of two primes p and q where <code>|3p−2q|<N<sup>1/4</sup></code>. Find the
 * smaller of the two factors and enter it as a decimal integer. Hint: use the
 * calculation below to show that √6N is close to <code>(3p+2q)/2</code> and
 * then adapt the method above to factor N.
 * <p>
 * <code>N = 72006226374735042527956443552558373833808445147399984182665305798191 \<br>
 * 63556901883377904234086641876639384851752649940178970835240791356868 \<br>
 * 77441155132015188279331812309091996246361896836573643119174094961348 \<br>
 * 52463970788523879939683923036467667022162701835329944324119217381272 \<br>
 * 9276147530748597302192751375739387929</code>
 * 
 * <p>
 * The only remaining mystery is why <code>A−√N<1</code>. This follows from the
 * following simple calculation. First observe that
 * <code>A<sup>2</sup>−N=((p+q)/2)<sup>2</sup>−N=(p<sup>2</sup>+2N+q<sup>2</sup>)/4−N=(p<sup>2</sup>−2N+q<sup>2</sup>)/4=(p−q)<sup>2</sup>/4</code>
 * .<br>
 * Now, since for all <code>x,y: (x−y)(x+y)=x<sup>2</sup>−y<sup>2</sup></code>
 * we obtain<br>
 * <code>A−√N=((A−√N)(A+√N))/(A+√N)=(A<sup>2</sup>−N)/(A+√N)=(p−q)<sup>2</sup
 * >/4/(A+√N)</code> <br>
 * and since √N ≤ A it follows that<br>
 * <code>A−N√≤(p−q)<sup>2</sup>/4/(2√N)=(p−q)<sup>2</sup>/(8√N)</code>. <br>
 * By assumption <b>(*)</b> we know that <code>(p−q)<sup>2</sup><4√N</code> and
 * therefore <code>A−√N≤4√N/8√N=1/2</code> as required.
 * <p>
 * Further reading: the method described above is a greatly simplified version
 * of a much more general <a
 * href="http://dl.acm.org/citation.cfm?id=1754517">result</a> on factoring when
 * the high order bits of the prime factor are known.
 * 
 * Enter the answer for factoring challenge #1 in the box below:
 * 
 * 
 * <h4>Question 4</h4>
 * The challenge ciphertext provided below is the result of encrypting a short
 * secret ASCII plaintext using the RSA modulus given in the first factorization
 * challenge. The encryption exponent used is e=65537. The ASCII plaintext was
 * encoded using PKCS v1.5 before the RSA function was applied, as described in
 * <a href="https://class.coursera.org/crypto-005/lecture/view?lecture_id=58">
 * Lecture 11.4</a>.
 * 
 * Use the factorization you obtained for this RSA modulus to decrypt this
 * challenge ciphertext and enter the resulting English plaintext in the box
 * below. Recall that the factorization of N enables you to compute φ(N) from
 * which you can obtain the RSA decryption exponent.
 * 
 * Challenge ciphertext (as a decimal integer):
 * <code>22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540</code>
 * After you use the decryption exponent to decrypt the challenge ciphertext you
 * will obtain a PKCS1 encoded plaintext. To undo the encoding it is best to
 * write the decrypted value in hex. You will observe that the number starts
 * with a '0x02' followed by many random non-zero digits. Look for the '0x00'
 * separator and the digits following this separator are the ASCII letters of
 * the plaintext. (note: the separator used here is '0x00', not '0xFF' as stated
 * in the lecture)
 * 
 * @author rustam
 * 
 */
public class Prog6 {
	private static BigInteger p;
	private static BigInteger q;

	public static void main(String[] args) {
		System.out.println("challenge#1 p: " + challenge1());
		System.out.println("challenge#2 p: " + challenge2());
		System.out.println("challenge#3 p: " + challenge3());
		System.out.println("challenge#3: " + challenge4());
	}

	public static BigInteger challenge1() {
		Apfloat N = new Apfloat(
				"179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581",
				1 << 8);
		Apint A = ApfloatMath.sqrt(N).ceil();
		Apint x = ApfloatMath.sqrt(ApfloatMath.pow(A, 2).subtract(N)).ceil();
		p = A.subtract(x).toBigInteger();
		q = A.add(x).toBigInteger();
		// Apint an = p.multiply(q);
		return p;
	}

	public static BigInteger challenge2() {
		Apfloat N = new Apfloat(
				"648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877",
				1 << 8);
		Apint A = ApfloatMath.sqrt(N).ceil();
		Apint x = ApfloatMath.sqrt(ApfloatMath.pow(A, 2).subtract(N)).ceil();
		Apint p = A.subtract(x);
		Apint q = A.add(x);
		Apint an = p.multiply(q);
		while (!an.subtract(N).equals(Apint.ZERO)) {
			A = A.add(Apint.ONE);
			x = ApfloatMath.sqrt(ApfloatMath.pow(A, 2).subtract(N)).ceil();
			p = A.subtract(x);
			q = A.add(x);
			an = p.multiply(q);
		}
		return p.toBigInteger();
	}

	/**
	 * Solution by Serge Le Breton from thread <a
	 * href="https://class.coursera.org/crypto-005/forum/thread?thread_id=453"
	 * >Week 6 Programming Assignment Q3</a>
	 * <p>
	 * <code>
	 * A = 3p + 2q<br> 
	 * A ~= sqrt(6N)<br> 
	 * (1) 6p= A - x <br>
	 * (2) 4q = A + x <br> 
	 * (2) - (1) => 4q - 6p = 2x => x = 2q - 3p => Integer. <br> 
	 * (2)*(1) => 24pq = A<sup>2</sup> -x<sup>2</sup> => 24N = A<sup>2</sup> -x<sup>2</sup> <br> 
	 * => x<sup>2</sup> = A<sup>2</sup> - 24N => x = sqrt(A<sup>2</sup> - 24N)
	 * </code>
	 * 
	 * @return
	 */
	public static BigInteger challenge3() {
		Apint six = new Apint(6);
		Apint two = new Apint(2);
		Apfloat N = new Apfloat(
				"720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929",
				1 << 10);
		Apfloat N6 = N.multiply(six);
		Apint A = ApfloatMath.sqrt(N6).multiply(two).ceil();
		Apint x = ApfloatMath.sqrt(
				A.multiply(A).subtract(N.multiply(new Apint(24)))).ceil();
		Apint p = A.subtract(x).divide(six).ceil();
		Apint q = N.divide(p).ceil();
		Apint an = p.multiply(q);
		Apint delta = an.subtract(N).ceil();
		while (!delta.equals(Apint.ZERO)) {
			p = p.subtract(Apint.ONE);
			q = N.divide(p).ceil();
			an = p.multiply(q);
			delta = an.subtract(N).ceil();
		}
		return p.toBigInteger();
	}

	public static String challenge4() {
		if (p == null || q == null)
			challenge1();
		BigInteger N = new BigInteger(
				"179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581");
		BigInteger fi = p.subtract(BigInteger.ONE).multiply(
				q.subtract(BigInteger.ONE));

		BigInteger e = new BigInteger(Integer.toString(65537));
		BigInteger d = e.modInverse(fi);
		BigInteger ct = new BigInteger(
				"22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540");
		BigInteger pkcs1v1_5 = ct.modPow(d, N);
		String enc = Utils.toHex(pkcs1v1_5.toByteArray());
		String ptEnc = enc.substring(enc.indexOf("00") + 2);
		String pt = new String(Utils.hexToBytes(ptEnc));
		return pt;
	}
}
